#summary Mycila Guice
#labels Featured

= Introduction =

[http://code.google.com/p/google-guice/ Google Guice] contributions:
 * *ServiceLoader* plugin (enables injection into loaded services)
 * *JSR250* supports improved from [http://code.google.com/p/guiceyfruit/ GuicyFruit]
 * *Custom Injector* with more useful methods which consider the whole Injector hierarchy
 * *CachedScope* to cache your binding for a specific duration

= Download =

Mycila event is deployed in maven 2 Central Repository:

http://repo2.maven.org/maven2/com/mycila/mycila-event/

{{{
<dependency>
    <groupId>com.mycila</groupId>
    <artifactId>mycila-guice</artifactId>
    <version>X.Y</version>
</dependency>
}}}

 * [http://code.google.com/p/mycila/source/browse/#svn/mycila-guice/trunk Browse source code]
 * [http://mycila.googlecode.com/svn/mycila-guice/trunk/ Checkout URL]

Snapshots are available at https://mc-repo.googlecode.com/svn/maven2/snapshots/com/mycila/mycila-guice/

= CachedScope =

You can optionally define your own annotation. In example, for most cases i want to cache my bindings only for 20 seconds. So I've created this annotation in my client program:

{{{
@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RUNTIME)
@ScopeAnnotation
public @interface Cached20Seconds {}
}}}

Then in my Guice module, i use the CachedScope like this:

{{{
final class MyModule extends AbstractModule {

    @Override
    protected void configure() {
        // bind cache annotation
        bindScope(Cached20Seconds.class, cachedScope(20, SECONDS));

        // configs, cached for 20 seconds and reloaded is rerquested after
        bind(UserConfig.class).to(UserConfigImpl.class).in(Cached20Seconds.class);
        bind(InternalConfig.class).to(InternalConfigImpl.class).in(Cached20Seconds.class);
    }

    @Provides
    @Cached20Seconds
    FileClassPath agentClassPath(Provider<FileScanner> selector,
                                 Provider<UserConfig> userConfig) {
        List<File> jars = new LinkedList<File>(selector.get().scan(userConfig.get().libDirectory()));
        jars.add(0, userConfig.get().libDirectory());
        jars.add(0, userConfig.get().dataDirectory());
        return FileClassPathClassLoader.create(Thread.currentThread().getContextClassLoader(), false, true).add(jars);
    }
}
}}}

= ServiceLoader =

{{{
binder.bind(AgentPlugin[].class)
    .toProvider(ServiceLoaderProvider.of(AgentPlugin.class).withClassLoader(ClassLoader.class))
    .in(Cached20Seconds.class);
}}}

This binding creates in a cached scope for 20 seconds a list of AgentPlugin instances on the classpath, loaded by the JDK ServiceLoader (META-INF/services/...). When loaded, each service will be injected with its dependencies.

`withClassLoader` is optional and takes as parameter the KEY of the binding where to get the classloader. In my case, i have a binding of type ClassLoader which points to the ClassLaoder instance i want to use to discover the services.