#summary Mycila Guice
#labels Featured

<wiki:toc max_depth="5" /> 

= Introduction =

MycilaGuice is an extension library to [http://code.google.com/p/google-guice/ Google Guice 3] which adds many features such as:

 contributions:
 * JSR250 (`@Resource`, `@PreDestroy`, `@PostConstruct`)
 * Additional scopes
 * Testing integration
 * Service loader facilities
 * Binding helpers
 * Support of legacy classes (classes you cannot modify to add @Inject)

The project can be used with Guice 2 or 3 and supports JSR330 (javax.inject)

= Download =

Mycila Guice is deployed in maven 2 Central Repository:

http://repo2.maven.org/maven2/com/mycila/mycila-guice/

{{{
<dependency>
    <groupId>com.mycila</groupId>
    <artifactId>mycila-guice</artifactId>
    <version>X.Y</version>
</dependency>
}}}

 * [http://code.google.com/p/mycila/source/browse/#svn/mycila-guice/trunk Browse source code]
 * [http://mycila.googlecode.com/svn/mycila-guice/trunk/ Checkout URL]

Snapshots and releases are also availables at
 * https://mc-repo.googlecode.com/svn/maven2/snapshots/com/mycila/mycila-guice/
 * https://mc-repo.googlecode.com/svn/maven2/releases/com/mycila/mycila-guice/

= Mycila Guice Features =

== JSR250 ==

=== Creating your injector ===

Using the plain old Guice way, by using the `Jsr250Module`.

{{{
Injector injector = Guice.createInjector(Stage.PRODUCTION, new MyModule(), new Jsr250Module());
}}}

Or by using the `Jsr250` helper class, which will return you a `Jsr250Injector`, which is a subclass of Guice's Injector.

{{{
Jsr250Injector jsr250Injector = Jsr250.createInjector(Stage.PRODUCTION, new MyModule());
}}}

We hardly recommend to use the later form because you can manage the lifecycle of the JSR250 injector and objects more easily with the destroy() method:

{{{
public interface Jsr250Injector extends Injector {
    void destroy();
}
}}}

=== Injecting using `@Resource` ===

You can inject fields and methods as usual, and also benefits of Guice's binding annotations and providers.

Fields are always injected before methods.

{{{
public class Account {

    @Resource
    Bank bank;

    String number;

    @Resource
    void init(Client client, @Named("RNG") Provider<Id> rng) {
        number = bank.id() + "" + client.id() + "" + rng.get().id();
    }

    public String getNumber() {
        return number;
    }
}
}}}

=== Controlling lifecycle with `@PostConstruct` and `@PreDestroy` ===

== Additional scopes ==

== Legacy support ==

== Service Loader ==

{{{
binder.bind(AgentPlugin[].class)
    .toProvider(ServiceLoaderProvider.of(AgentPlugin.class).withClassLoader(ClassLoader.class))
    .in(Cached20Seconds.class);
}}}

This binding creates in a cached scope for 20 seconds a list of AgentPlugin instances on the classpath, loaded by the JDK ServiceLoader (META-INF/services/...). When loaded, each service will be injected with its dependencies.

*or*

{{{
install(ServiceLoaderModule.withClassLoader(ClassLoader.class).of(AgentPlugin.class));
}}}

In this case. the module creates a binding of key `Set<AgentPlugin>` containing all loaded and injected instances from the META-INF/services definitions.

`withClassLoader` is optional and takes as parameter the KEY of the binding where to get the classloader. In my case, i have a binding of type ClassLoader which points to the ClassLaoder instance i want to use to discover the services.

== Binding helpers ==

== Testing integration ==