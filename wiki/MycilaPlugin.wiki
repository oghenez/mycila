#summary Mycila Plugin Framework
#labels Featured

== Introduction ==

Mycila Plugin Framework is a really little (4 classes) plugin framework that enables you to build quickly a plugin architecture in your application, supporting dependencies.

== Download ==

*mycila-plugin* is available
 * from the [http://code.google.com/p/mycila/downloads/list download section]
 * from our [http://code.google.com/p/mc-repo/ alternate maven repository]
 * and maybe (if deployed) in the central maven repository

== Documentation ==

Javadoc, Source XREF, Test reports, Coverages, ...

http://old.mycila.com/p/mycila/mycila-plugin/

== Manual ==

First you need to define what is a plugin in your project. The abstract class or interface should extend the Plugin interface.

{{{
package my.sample;
import com.mycila.plugin.api.Plugin;
public interface MyPlugin extends Plugin {
    void execute();
}
}}}

The usage is very easy. It works nearly like the JDK [http://java.sun.com/javase/6/docs/api/index.html?java/util/ServiceLoader.html ServiceLoader] class:

{{{
PluginManager<MyPlugin> manager = new PluginManager<MyPlugin>(MyPlugin.class, "META-INF/myapp/plugins.properties");

for (MyPlugin plugin : manager.getResolver().getResolvedPlugins()) {
    plugin.execute();
}
}}}

You just have to provide your plugin type (which implement the Plugin interface as we will see later), and also provide the resources to check on the classpath. The PluginManager will load all the plugins found in all `META-INF/myapp/plugins.properties` resources.

And is you want to control your self which plugin to add, you could also use this way of buidling a plugin manager:

{{{
PluginManager<MyPlugin> manager = new PluginManager<MyPlugin>(MyPlugin.class);

manager.getCache().registerPlugin("myPlugin1", new MyPluginInstance1());
manager.getCache().registerPlugin("myPlugin2", new MyPluginInstance2());

for (MyPlugin plugin : manager.getResolver().getResolvedPlugins()) {
    plugin.execute();
}
}}}

At runtime, you can add, remove plugins, reload all plugins, ... 

=== The PluginManager ===

From the [http://mycila.googlecode.com/svn/mycila-plugin/trunk/src/main/java/com/mycila/plugin/spi/PluginManager.java PluginManager], you have access to three components:

 * The [http://mycila.googlecode.com/svn/mycila-plugin/trunk/src/main/java/com/mycila/plugin/api/PluginLoader.java PluginLoader]: responsible of loading the plugins
 * The [http://mycila.googlecode.com/svn/mycila-plugin/trunk/src/main/java/com/mycila/plugin/api/PluginCache.java PluginCache]: responsible of caching in memory available plugins
 * The [http://mycila.googlecode.com/svn/mycila-plugin/trunk/src/main/java/com/mycila/plugin/api/PluginResolver.java PluginResolver]: responsible of resolving the plugins and their order of execution

=== PluginLoader ===

The plugin loader enables you to reload all plugins from the descriptor you specified in the plugin manager. You can also exclude some plugins from loading: this is useful if a third party provides a plugin that crashes.

=== PluginCache ===

When you retreive the list of plugins, you get it from the plugin cache, which lazily load them with a laoder. Once loaded, you can add / remove / clear plugins loaded in memory with the PluginCache.

=== PluginResolver ===

The plugin resolver is the access point of your plugins. It contains basic getters (get, getAll, contains, ...) methods. 

The main interest of this interface is to resolve *plugin dependencies* and returns you the list of plugin names of plugin dependencies in order of execution. See methods `getResolvedPluginsName` and `getResolvedPlugins`

== Plugin dependencies ==

Mycila Plugin Frameowrk supports plugin dependencies. When you declare a plugin, you have to implement the Plugin interface:

{{{
package com.mycila.plugin.api;

import java.util.List;

/**
 * Defines a plugin and its dependencies / order of execution
 *
 * @author Mathieu Carbou (mathieu.carbou@gmail.com)
 */
public interface Plugin {

    /**
     * Get the list of plugins that should be executed before this one
     *
     * @return empty list, or a list of plugin names
     */
    List<String> getBefore();

    /**
     * Get the list of plugins that should be executed after this one
     *
     * @return empty list, or a list of plugin names
     */
    List<String> getAfter();
}
}}}

Your implementation has to return two set of dependencies: 
 * Through `getBefore`, this is the list of dependencies that should be executed before this plugin. You can return en empty list of you do not have such dependency.
 * Through `getAfter`, this is the list of dependencies that should be executed after this plugin. You can return en empty list of you do not have such dependency.

The PluginResolver resolves all the dependencies of all plugins and returns an execution list. If cyclic dependencies are found, an exception is thrown.