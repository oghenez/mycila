#summary Mycila Event, a brand-new powerful in-process Event System
#labels Featured

= Introduction =
Mycila Event
Mycila Event is a new powerful event framework for in-memory event management. It has a lot of features similar to [https://eventbus.dev.java.net/ EventBus] but is better designed, uses Java Concurrency features and has a lot of more event features than EventBus, which are really useful when you work with a complex system driven by event messaging.

= Sample =

{{{
import static com.mycila.event.api.topic.Topics.*;

// first create an event service
EventService eventService = EventServices.newEventService();

// then subscribe
TopicMatcher matcher = only("app/events/swing/button").or(topics("app/events/swing/fields/**"));
eventService.subscribe(matcher, String.class, new Subscriber<String>() {
    public void onEvent(Event<String> event) throws Exception {
        System.out.println("Received: " + event.source());
    }
});

// you can add a listener to oppose a veto to the events
eventService.register(only("app/events/swing/button"), String.class, new Vetoer<String>() {
    public void check(VetoableEvent<String> vetoableEvent) {
        if(vetoableEvent.event().source().equals("password"))
            vetoableEvent.veto();
    }
});

// and publish
eventService.publish(topic("app/events/swing/button"), "Hello !");
}}}

= Download =

Mycila event is deployed in maven 2 Central Repository:

http://repo2.maven.org/maven2/com/mycila/mycila-event/

{{{
<dependency>
    <groupId>com.mycila</groupId>
    <artifactId>mycila-event</artifactId>
    <version>X.Y</version>
</dependency>
}}}

= Features =

== In-Memory event system ==

Mycila Event is not a JMS solution ! Like EventBus, Mycila Event resolves intra-process communication. In example, it can be used in a Swing GUI or in a complex modular framework to handle communication between plugins.

Thus, *Mycila Event must be fast, thread-safe and scalable.*

== Memory management == 

Like EventBus, Mycila Event supports *hard and weak subscriptions*. A hard subscription will always remain and must be unregistered if not needed anymore. A weak subscription will be automatically removed when the subscriber is no longer in use.

By default, if nothing is specified, Mycila Event uses a hard reference. this is very useful when you simply bind a listener like this:

{{{
eventService.subscribe(matcher, String.class, new Subscriber<String>() {
    public void onEvent(Event<String> event) throws Exception {
        System.out.println("Received: " + event.source());
    }
});
}}}

Reachability control can be done by annotating the class with `@Reference`. In example, suppose you have a plugin class subscribing for events. You can annotate the class like this:

{{{
@Reference(Reachability.WEAK)
public class MyPlugin implements Subscriber<String> {
    public void onEvent(Event<String> event) throws Exception {
        System.out.println("Received: " + event.source());
    }
    public void start() {
        // start the plugin
    }
}

MyPlugin pluginLoadedByAnotherSystem = ...;
eventService.subscribe(matcher, String.class, pluginLoadedByAnotherSystem);
}}}

When registering the plugin, a weak registration will be done so that if the plugin is unloaded or not used anymore, the subscription could be removed automatically.

== Veto system ==

To control event publishing, you can register listeners to *intercept events before they are published*. If a veto is opposed, the event won't be published. You can oppose a veto simply by calling `vetoableEvent.veto()`.

{{{
eventService.register(only("app/events/swing/button"), MyEventType.class, new Vetoer<String>() {
    public void check(VetoableEvent<String> vetoableEvent) {
        [...]
        vetoableEvent.veto();
        [...]
    }
});
}}}

== Exception handling ==

By default, if a subscriber launches an exception, the exception is put in a list and an aggregate exception will be thrown when all subscribers will be processed. This behavior enables subscribers to be completely independent since the publishing won't be interrupted by a failing subscriber.

You can change this default behavior by using your proper `ErrorHandler`. The class `ErrorHandlers` already has several methods to help you provide error handlers:

 * `ErrorHandlers.ignoreErrors()`: ignore all exceptions thrown by subscribers
 * `ErrorHandlers.rethrowErrorsWhenFinished()`: the default behavior: when an event is published, stack all errors and throw an aggregated exception at the end if some errors occured.
 * `ErrorHandlers.rethrowErrorsImmediately()`: the behavior if error handlers weren't be there: if a publisher fail, the publishing is stopped and its exception thrown.

`ErrorHandlers` also has other methods to help you build your own `ErrorHandler` class and its associated provider `ErrorHandlerProvider`. At each publishing, `ErrorHandlerProvider.get()` is called to obtain a new `ErrorHandler`. Note that `ErrorHandlerProvider.get()` can act as a singleton: you only need to wrap your `ErrorHandlerProvider` or `ErrorHandler` by using `ErrorHandlers.singleton(...)` and the same instance will be reused each time.

== Topic Matchers ==

enable a subscriber (and a vetoers) to subscribe to many topics

== Asynchronous event dispatching ==

== Multicasting events ==

== Annotation support ==

you can annotate your methods to decouple your code from Mycila Event and subscribe, publish and veto