#summary Mycila Event, a brand-new powerful in-process Event System
#labels Featured

<wiki:toc max_depth="5" /> 

= Introduction =

Mycila Event
Mycila Event is a new powerful event framework for in-memory event management. It has a lot of features similar to [https://eventbus.dev.java.net/ EventBus] but is better designed, uses Java Concurrency features and has a lot of more event features than EventBus, which are really useful when you work with a complex system driven by event messaging.

= Sample =

{{{
import static com.mycila.event.api.topic.Topics.*;

// first create an event service
Dispatcher dispatcher = Dispatchers.SYNCHRONOUS_UNORDERED_DISPATCHER.create(ErrorHandlers.rethrowErrorsAfterPublish());

// then subscribe
TopicMatcher matcher = only("app/events/swing/button").or(topics("app/events/swing/fields/**"));
dispatcher.subscribe(matcher, String.class, new Subscriber<String>() {
    public void onEvent(Event<String> event) throws Exception {
        System.out.println("Received: " + event.source());
    }
});

// you can add a listener to oppose a veto to the events
dispatcher.register(only("app/events/swing/button"), String.class, new Vetoer<String>() {
    public void check(VetoableEvent<String> vetoableEvent) {
        if(vetoableEvent.event().source().equals("password"))
            vetoableEvent.veto();
    }
});

// and publish
dispatcher.publish(topic("app/events/swing/button"), "Hello !");
}}}

When you subscribe, you need to give to which topic to subscribe and for which event type.

= Download =

Mycila event is deployed in maven 2 Central Repository:

http://repo2.maven.org/maven2/com/mycila/mycila-event/

{{{
<dependency>
    <groupId>com.mycila</groupId>
    <artifactId>mycila-event</artifactId>
    <version>X.Y</version>
</dependency>
}}}

= Features =

== Topics and Event types ==

When you subscribe, you subscribe in a Topic for a given event type. Event type subclasses are allowed to be received by a subscriber accepting its super-class. In example, if you subscribe to `Topic.topic("buttons/ok")` with event type `ActionListener.class`, you can publish any implementation of `ActionListener` and it will be received by subscribers accepting the type (and sub-types) `ActionListener`.

== In-Memory event system ==

Mycila Event is not a JMS solution ! Like EventBus, Mycila Event resolves intra-process communication. In example, it can be used in a Swing GUI or in a complex modular framework to handle communication between plugins.

Thus, *Mycila Event must be fast, thread-safe and scalable.*

== Memory management ==

Like EventBus, Mycila Event supports *hard and weak subscriptions*. A hard subscription will always remain and must be unregistered if not needed anymore. A weak subscription will be automatically removed when the subscriber is no longer in use.

By default, if nothing is specified, Mycila Event uses a hard reference. this is very useful when you simply bind a listener like this:

{{{
dispatcher.subscribe(matcher, String.class, new Subscriber<String>() {
    public void onEvent(Event<String> event) throws Exception {
        System.out.println("Received: " + event.source());
    }
});
}}}

Reachability control can be done by annotating the class with `@Reference`. In example, suppose you have a plugin class subscribing for events. You can annotate the class like this:

{{{
@Reference(Reachability.WEAK)
public class MyPlugin implements Subscriber<String> {
    public void onEvent(Event<String> event) throws Exception {
        System.out.println("Received: " + event.source());
    }
    public void start() {
        // start the plugin
    }
}

MyPlugin pluginLoadedByAnotherSystem = ...;
dispatcher.subscribe(matcher, String.class, pluginLoadedByAnotherSystem);
}}}

When registering the plugin, a weak registration will be done so that if the plugin is unloaded or not used anymore, the subscription could be removed automatically.

== Veto system ==

To control event publishing, you can register listeners to *intercept events before they are published*. If a veto is opposed, the event won't be published. You can oppose a veto simply by calling `vetoableEvent.veto()`.

{{{
dispatcher.register(only("app/events/swing/button"), MyEventType.class, new Vetoer<String>() {
    public void check(VetoableEvent<String> vetoableEvent) {
        [...]
        vetoableEvent.veto();
        [...]
    }
});
}}}

== Exception handling ==

By default, if a subscriber launches an exception, the exception is put in a list and an aggregate exception will be thrown when all subscribers will be processed. This behavior enables subscribers to be completely independent since the publishing won't be interrupted by a failing subscriber.

You can change this default behavior by using your proper `ErrorHandler`. The class `ErrorHandlers` already has several methods to help you provide error handlers:

 * `ErrorHandlers.ignoreErrors()`: ignore all exceptions thrown by subscribers
 * `ErrorHandlers.rethrowErrorsAfterPublish()`: the default behavior: when an event is published, stack all errors and throw an aggregated exception at the end if some errors occured.
 * `ErrorHandlers.rethrowErrorsImmediately()`: the behavior if error handlers weren't be there: if a publisher fail, the publishing is stopped and its exception thrown.

`ErrorHandlers` also has other methods to help you build your own `ErrorHandler` class and its associated provider `ErrorHandlerProvider`. At each publishing, `ErrorHandlerProvider.get()` is called to obtain a new `ErrorHandler`. Note that `ErrorHandlerProvider.get()` can act as a singleton: you only need to wrap your `ErrorHandlerProvider` or `ErrorHandler` by using `ErrorHandlers.singleton(...)` and the same instance will be reused each time.

To create an EventService with the appropriate event handler, you just have to set the `ErrorHandlerProvider` instance when creating it:

{{{
Dispatcher dispatcher = Dispatchers.SYNCHRONOUS_UNORDERED_DISPATCHER.create(ErrorHandlers.ignoreErrorsh());
}}}

== Topic Matchers ==

When you register a subscriber or a vetoer, you need to pass the type of event you want to receive and a matcher to math topics you want to listen to. TopicMatcher can be created with the `Topics` class. You can compose matchers.
 * `Topics.only(exactName)`: matches a single topic name. *Example:* `Topics.only("app/events/buttons/ok")`
 * `Topics.topics(pattern)`: matches several topic by using an Ant expression. *Example:* `Topics.topics("app/events/buttons/**")`
 * `Topics.any()`: matches any topic
 * `Topics.not(matcher)`: invert the given matcher
 * `matcher.and(matcher)`: any matcher can be composed with another matcher with an *and*. In this case, all matchers must match given topic event for the subscriber to receive it. This is quite an uncommon case.
 * `matcher.or(matcher)`: any matcher can be composed with another matcher with an *or*. In this case, the subscriber will receive events matching the two matchers. This is a common case where you would like to receive in one subscriber the same events from different topics.

In example, to set a catch-all subscriber, you could do:

{{{
dispatcher.subscribe(Topics.any(), Object.class, new Subscriber<Object>() {
    public void onEvent(Event<Object> event) throws Exception {
        System.out.println("Received: " + event.source());
    }
});
}}}

== Event dispatching strategies ==

There are several strategies regarding about how you want the order of events and the order of listeners be respected and whether or not you have multiple threads publishing events.

=== Synchronous Blocking Dispatching ===

 * Listeners are called in the order they subscribed
 * Events are published one after one
 * Only one thread can publish at a time

This strategy guarantees the order of listeners called and that only one thread will hit the listeners at a time. Thus, your listeners don't need to be thread-safe. The publish method thus block until the previous publishing is finished.

This strategy is better when your publishers don't need to execute fast, and when your subscribers are fast to execute.

{{{
Dispatcher dispatcher = Dispatchers.SYNCHRONOUS_BLOCKING_DISPATCHER.create(ErrorHandlers.rethrowErrorsAfterPublish());
}}}

=== Synchronous Non Blocking Dispatching ===

 * Listeners are called in the order they subscribed
 * Events are published immediately
 * Several threads can publish at a time

This strategy guarantees the order of listeners called. The publish method only block for the current thread, meaning that a thread can be publishing while another thread also starting publishing an event. Thus, your subscribers can be hit at the same time by two or more threads.

{{{
Dispatcher dispatcher = Dispatchers.SYNCHRONOUS_UNORDERED_DISPATCHER.create(ErrorHandlers.rethrowErrorsAfterPublish());
}}}

=== Asynchronous Ordered Dispatching ===

 * Listeners are called in the order they subscribed
 * Events are published in order
 * Many threads can enqueue an event at one time
 * One background thread is responsible to dequeue and fire events
 * A queue is used to enqueue events before they are processed.

This strategy guarantees the order of listeners called and the order of published events. The publish method *does not block* and the publisher thread immediately returns. The event is queued and wait for its turn to be processed by the background thread.

This strategy is useful when your publishers must execute as fast as possible, but be careful to also have fast subscribers to not fill the queue.

{{{
Dispatcher dispatcher = Dispatchers.ASYNCHRONOUS_ORDERED_DISPATCHER.create(ErrorHandlers.rethrowErrorsAfterPublish());
}}}

=== Asynchronous Unordered Dispatching ===

 * Listeners are called in the order they subscribed
 * Events are published unordered
 * Many threads can publish an event at one time
 * Several background threads are responsible for firing events

This strategy guarantees the order of listeners called, but not the order of event. Basically, each call to publics will return immediately. All events in the queue are handled by a thread pool with the maximum size given.

This strategy is useful when your publishers must execute as fast as possible, and event publishing needs to be processed quickly, but by respecting listener order. This dispatcher can be seen as a concurrent event dispatcher, respecting listener order.

When creating an Asynchronous Unordered Dispatching, you can configure the number of threads consuming events and handling publishing. If you create only one thread, this will have the same behavior as an Asynchronous Ordered Dispatching.

{{{
// create 10 dispatcher threads waiting for events
Dispatcher dispatcher = Dispatchers.ASYNCHRONOUS_UNORDERED_DISPATCHER.create(ErrorHandlers.rethrowErrorsAfterPublish());
}}}

=== Broadcast Ordered Dispatching ===

 * Listeners are called unordered
 * Events are published in order
 * Many threads can enqueue an event at one time
 * A thread-pool is used to send each event to each subscriber

This strategy guarantees the order of events but calls listeners unordered. The goal of a broadcasting is to reach as fast as possible each listeners in the smallest amount of time. A thread-pool is used to handle subscriber's execution.

This type of dispatching is really useful when you don't care about ordering and want to publish fast and want your subscribers to be called as fast as possible.

Note that when a thread publishes an event, it is enqueued. A thread is used to equeeu events one per one and fire this event concurrently to all subscribers. The publish method returns immediately, but for another event to be processed, all concurrent firing of the previous event must have finished.

{{{
Dispatcher dispatcher = Dispatchers.BROADCAST_ORDERED_DISPATCHER.create(ErrorHandlers.rethrowErrorsAfterPublish());
}}}

=== Broadcast Unordered Dispatching ===

 * Listeners are called unordered
 * Events are published unordered
 * Many threads can enqueue an event at one time
 * A thread-pool is used to send each event to each subscriber

This type of dispatching is really useful when you don't care about any ordering. Since the publish method does not block, any thread will be able to publish events really fast and a thread-pool is used to process them all, unordered.

Thus, subscribers taking a long time to execute don't affect publishing of other events to other subscribers.

{{{
Dispatcher dispatcher = Dispatchers.BROADCAST_UNORDERED_DISPATCHER.create(ErrorHandlers.rethrowErrorsAfterPublish());
}}}

== Annotation support ==

You can annotate your methods to decouple your code from Mycila Event and subscribe, publish and veto.

{{{
//TODO
}}}