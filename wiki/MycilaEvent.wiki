#summary Mycila Event, a brand-new powerful in-process Event System
#labels Featured

= Introduction =

Mycila Event
Mycila Event is a new powerful event framework for in-memory event management. It has a lot of features similar to [https://eventbus.dev.java.net/ EventBus] but is better designed, uses Java Concurrency features and has a lot of more event features than EventBus, which are really useful when you work with a complex system driven by event messaging.

= Sample =

{{{
import static com.mycila.event.api.topic.Topics.*;

// first create an event service
EventService eventService = EventServices.newEventService();

// then subscribe
TopicMatcher matcher = only("app/events/swing/button").or(topics("app/events/swing/fields/**"));
eventService.subscribe(matcher, String.class, new Subscriber<String>() {
    public void onEvent(Event<String> event) throws Exception {
        System.out.println("Received: " + event.source());
    }
});

// you can add a listener to oppose a veto to the events
eventService.register(only("app/events/swing/button"), String.class, new Vetoer<String>() {
    public void check(VetoableEvent<String> vetoableEvent) {
        if(vetoableEvent.event().source().equals("password"))
            vetoableEvent.veto();
    }
});

// and publish
eventService.publish(topic("app/events/swing/button"), "Hello !");
}}}

When you subscribe, you need to give to which topic to subscribe and for which event type.

= Download =

Mycila event is deployed in maven 2 Central Repository:

http://repo2.maven.org/maven2/com/mycila/mycila-event/

{{{
<dependency>
    <groupId>com.mycila</groupId>
    <artifactId>mycila-event</artifactId>
    <version>X.Y</version>
</dependency>
}}}

= Features =

== Topics and Event types ==

When you subscribe, you subscribe in a Topic for a given event type. Event type subclasses are allowed to be received by a subscriber accepting its super-class. In example, if you subscribe to `Topic.topic("buttons/ok")` with event type `ActionListener.class`, you can publish any implementation of `ActionListener` and it will be received by subscribers accepting the type (and sub-types) `ActionListener`.

== In-Memory event system ==

Mycila Event is not a JMS solution ! Like EventBus, Mycila Event resolves intra-process communication. In example, it can be used in a Swing GUI or in a complex modular framework to handle communication between plugins.

Thus, *Mycila Event must be fast, thread-safe and scalable.*

== Memory management ==

Like EventBus, Mycila Event supports *hard and weak subscriptions*. A hard subscription will always remain and must be unregistered if not needed anymore. A weak subscription will be automatically removed when the subscriber is no longer in use.

By default, if nothing is specified, Mycila Event uses a hard reference. this is very useful when you simply bind a listener like this:

{{{
eventService.subscribe(matcher, String.class, new Subscriber<String>() {
    public void onEvent(Event<String> event) throws Exception {
        System.out.println("Received: " + event.source());
    }
});
}}}

Reachability control can be done by annotating the class with `@Reference`. In example, suppose you have a plugin class subscribing for events. You can annotate the class like this:

{{{
@Reference(Reachability.WEAK)
public class MyPlugin implements Subscriber<String> {
    public void onEvent(Event<String> event) throws Exception {
        System.out.println("Received: " + event.source());
    }
    public void start() {
        // start the plugin
    }
}

MyPlugin pluginLoadedByAnotherSystem = ...;
eventService.subscribe(matcher, String.class, pluginLoadedByAnotherSystem);
}}}

When registering the plugin, a weak registration will be done so that if the plugin is unloaded or not used anymore, the subscription could be removed automatically.

== Veto system ==

To control event publishing, you can register listeners to *intercept events before they are published*. If a veto is opposed, the event won't be published. You can oppose a veto simply by calling `vetoableEvent.veto()`.

{{{
eventService.register(only("app/events/swing/button"), MyEventType.class, new Vetoer<String>() {
    public void check(VetoableEvent<String> vetoableEvent) {
        [...]
        vetoableEvent.veto();
        [...]
    }
});
}}}

== Exception handling ==

By default, if a subscriber launches an exception, the exception is put in a list and an aggregate exception will be thrown when all subscribers will be processed. This behavior enables subscribers to be completely independent since the publishing won't be interrupted by a failing subscriber.

You can change this default behavior by using your proper `ErrorHandler`. The class `ErrorHandlers` already has several methods to help you provide error handlers:

 * `ErrorHandlers.ignoreErrors()`: ignore all exceptions thrown by subscribers
 * `ErrorHandlers.rethrowErrorsWhenFinished()`: the default behavior: when an event is published, stack all errors and throw an aggregated exception at the end if some errors occured.
 * `ErrorHandlers.rethrowErrorsImmediately()`: the behavior if error handlers weren't be there: if a publisher fail, the publishing is stopped and its exception thrown.

`ErrorHandlers` also has other methods to help you build your own `ErrorHandler` class and its associated provider `ErrorHandlerProvider`. At each publishing, `ErrorHandlerProvider.get()` is called to obtain a new `ErrorHandler`. Note that `ErrorHandlerProvider.get()` can act as a singleton: you only need to wrap your `ErrorHandlerProvider` or `ErrorHandler` by using `ErrorHandlers.singleton(...)` and the same instance will be reused each time.

To create an EventService with the appropriate event handler, you just have to set the `ErrorHandlerProvider` instance when creating it:

{{{
EventService eventService = EventServices.newEventService(ErrorHandlers.ignoreErrors());
}}}

== Topic Matchers ==

When you register a subscriber or a vetoer, you need to pass the type of event you want to receive and a matcher to math topics you want to listen to. TopicMatcher can be created with the `Topics` class. You can compose matchers.
 * `Topics.only(exactName)`: matches a single topic name. *Example:* `Topics.only("app/events/buttons/ok")`
 * `Topics.topics(pattern)`: matches several topic by using an Ant expression. *Example:* `Topics.topics("app/events/buttons/**")`
 * `Topics.any()`: matches any topic
 * `Topics.not(matcher)`: invert the given matcher
 * `matcher.and(matcher)`: any matcher can be composed with another matcher with an *and*. In this case, all matchers must match given topic event for the subscriber to receive it. This is quite an uncommon case.
 * `matcher.or(matcher)`: any matcher can be composed with another matcher with an *or*. In this case, the subscriber will receive events matching the two matchers. This is a common case where you would like to receive in one subscriber the same events from different topics.

In example, to set a catch-all subscriber, you could do:

{{{
eventService.subscribe(Topics.any(), Object.class, new Subscriber<Object>() {
    public void onEvent(Event<Object> event) throws Exception {
        System.out.println("Received: " + event.source());
    }
});
}}}

== Event dispatching strategies ==

There are several strategies regarding about how you want the order of events and the order of listeners be respected and where or not you have multiple threads publishing events.

=== Full-ordered dispatching ===

Listeners are called in the order they subscribed + Events are published in order. So at a time t, there will only be at most one event published to one listener. The second event

{{{
EventService service = EventServices.
}}}

=== Ordered Per-thread ===

=== Asynchronous ===

=== Multicasting ===

== Annotation support ==

You can annotate your methods to decouple your code from Mycila Event and subscribe, publish and veto