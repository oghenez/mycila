#summary How to create your own plugins
#sidebar PluginBar

Creating your own plugins for Mycila Testing Framework is very easy. As an example is better than many words, let's start by a tutorial on how to write a JMock Plugin.

=== The Plugin API ===

Plugins must implement [http://mycila.googlecode.com/svn/mycila-testing/trunk/mycila-testing-api/src/main/java/com/mycila/testing/core/plugin/TestPlugin.java TestPlugin], but *we hardly advise you extend [http://mycila.googlecode.com/svn/mycila-testing/trunk/mycila-testing-api/src/main/java/com/mycila/testing/core/plugin/DefaultTestPlugin.java DefaultTestPlugin]* to avoid APi breaks and to avoid implementing all methods unecessary for you.

An example of implementation would be:

{{{
public final class MyPlugin extends DefaultTestPlugin{
    @Override
    public List<String> getBefore() {
        return null;
    }
    @Override
    public List<String> getAfter() {
        return null;
    }
    @Override
    public void prepareTestInstance(Context context) {
    }
}
}}}

We don't care about receiving beforeTest, afterTest and afterClass events.

`getBefore` and `getAfter` comes from [http://code.google.com/p/mycila/wiki/MycilaPlugin Mycila Plugin Framework]. If provided, they help defined the order of execution of the plugins. 

In example, suppose we have a Spring plugin that checks for beans to include in the Application Context. If we execute the JMock Plugin before the Spring plugin, we will be able to create the Spring Application Context base on created mocks.

The [http://mycila.googlecode.com/svn/mycila-testing/trunk/mycila-testing-api/src/main/java/com/mycila/testing/core/api/TestContext.java TestContext] enables the plugin to access the test instance to enhance, and also sharing data with other plugins through context attributes. A plugin can also access the plugin manager and resolver, which provides the plugin execution flow. To have more information about the plugin infrastructure, please see [http://code.google.com/p/mycila/wiki/MycilaPlugin Mycila Plugin Framework] documentation.

=== First, What do we want for our plugin ? ===

 * Create and inject mock
 * Be able to access the mockery to verify expectations

We would like to be able to write tests using JMock like this:

{{{
public final class MyTest extends MycilaTestNGTest {

    @MockContext
    Mockery mockery;

    @Mock
    Service service;

    @Test
    public void test_go() {
        mockery.checking(new Expectations() {{
            // some expectations
        }});
        // execute test
        mockery.assertIsSatisfied();
    }
}
}}}

 * *@Mock* defines a mock to create and inject
 * *@MockContext* defines a place where to inject the mockery

=== Let's code our plugin ! ===

First, we need to have two annotations:

{{{
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD})
public @interface Mock {
}

@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD})
public @interface MockContext {
}
}}}

Then, we prepare our plugin class:

{{{
public final class MyPlugin extends DefaultTestPlugin {
    @Override
    public List<String> getAfter() {
        return Arrays.asList("guice1", "spring");
    }
    @Override
    public void prepareTestInstance(Context context) {
        //TODO: implement
    }
}
}}}

The implementation is quite simple:

 # Get the mocks to create (by listing fields annotated by @Mock)
 # Create a mockery
 # If @MockContext annotated fields are found, inject the Mockery
 # Create and inject mocks

{{{
Field[] mocks = context.getTest().getFieldsAnnotatedWith(Mock.class);
Mockery mockery = new Mockery();
for (Field field : context.introspector().selectFields(and(fieldsAccepting(Mockery.class), fieldsAnnotatedBy(MockContext.class)))) {
    context.introspector().set(field, mockery);
}
for (Field field : mocks) {
    context.introspector().set(field, mockery.mock(field.getType(), field.getDeclaringClass().getName() + "." + field.getName()));
}
}}}

=== Package and distribute ===

Now that we have a working and testable plugin, it would be nice if it could be loaded automatically if our plugin jar is in the classpath. To detect plugins, Mycila Plugin Framework reads all property files in the classpath named:

*META-INF/mycila/testing/plugins.properties*

So we just have to include a `plugins.properties` files in our jar, with the following content:

{{{
jmock=MyPlugin
}}}

Et voila ! We've made with 3 classes (two annotation and a plugin class) and a property file, a JMock plugin for Mycila Testing, that can be automatically loaded and executed to enhance your tests.