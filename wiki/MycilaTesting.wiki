#summary Mycila Testing Framework
#labels Featured

//TODO: page per Plugin + Migration Guide

== Testing ==

Integration of Guice Testing in your app is as simple a knowing only two annotations:

 * `@GuiceContext`
 * `@ModuleProvider`

===TestNG support, extending TestNGGuiceTest===

`TestNGGuiceTest` extends `org.testng.Assert` and provides access method like:

`protected Injector injector()`

{{{
@GuiceContext(modules = {Module1.class, Module2.class})
public final class MyTest extends TestNGGuiceTest {

    @Inject
    private Service1 service1;
    
    @Inject
    private Service2 service2;
    
    @Test
    public void test() {
        // test using services, or injector like injector().doSomething()
    }
}
}}}

===TestNG support, without extending any class===

You have to register your test yourself and access `GuiceTestContext`.

{{{
@GuiceContext(modules = {Module1.class})
public final class MyTest {

    @Inject
    private Service1 service1;
    
    @BeforeClass
    public void setup()
    {
        TestContext.register(this);
    }

    @Test
    public void test() {
        // test using services
        // you can access injector like this: 
        Injector i = TestContext.get().injector();
    }
}
}}}

===JUnit support===

Junit supports works the same. You can either subclass `JUnitGuiceTest` or use the annotation `@RunWith(JUnitGuiceTestRunner.class)` if you do not want any extend.

===Providing modules===

Besides specifying modules in the `@GuiceContext` annotation, you can also provide directly module instances by marking some methods with `@ModuleProvider` annotation. Guice injector will be created with modules defined in the `@GuiceContext` annotation plus the modules returned by `@ModuleProvider` methods.

Example:

{{{
@GuiceContext(modules = {Module1.class})
public final class MyTest {

    @Inject
    private Service1 service1;
    
    @BeforeClass
    public void setup()
    {
        TestContext.register(this);
    }

   @ModuleProvider
    public Module getModule3() {
        return new AbstractModule() {
            protected void configure() {
                bind(Service3.class).to(Service3Impl.class);
            }
        };
    }

    @ModuleProvider
    public Module[] getAdditionalModules() {
        return new Module[]{new AbstractModule() {
            protected void configure() {
                bind(Service4.class).to(Service4Impl.class);
            }
        }, new AbstractModule() {
            protected void configure() {
                bind(Service5.class).to(Service5Impl.class);
            }
        }};
    }

    @ModuleProvider
    public Collection<Module> getAdditionalModulesAsCollection() {
        return Collections.emptyList();
    }

    @Test
    public void test() {
        // test using services
        // you can access injector like this: 
        Injector i = TestContext.get(this).injector();
    }
}
}}}

===Providing bindings===

There is two ways to provide Guice bingings: either by implementing in your test the Module interface (or extends AbstractModule), or by using `@Bind` annotation.

Examples:

We have a Service interface, and a Repository injected into the Service's implementation binded in Guice module MyModule.

{{{
@GuiceContext(modules = MyModule.class)
public final class MyTest extends AbstractModule {

    @Inject
    Service myService;

    @BeforeClass
    public void setup() {
        TestContext.register(this);
    }

    public void configure() {
        bind(Repository.class).to(HibernateRepository.class).in(AScope.class);
    }

    @Test
    public void test_service_method() throws Exception {
        [...]
    }
}
}}}

Using the `@Bind` annotation, it is simple as below:

{{{
@GuiceContext(modules = MyModule.class)
public final class MyTest {

    @Inject
    Service myService;

    @Bind
    Repository repo = new HibernateRepository();

    @BeforeClass
    public void setup() {
        TestContext.register(this);
    }

    @Test
    public void test_service_method() throws Exception {
        [...]
    }
}
}}}

===JMock support===

In reality, you probably do not want to use the real implementation of Repository. You can mock the Repository by adding `@Mock` annotation like this:

{{{
@GuiceContext(modules = MyModule.class)
public final class EnvironmentServiceTest {

    @Inject
    MyService service;

    @Mock
    @Bind
    Repository repository;

    @BeforeClass
    public void setup() {
        TestContext.register(this);
    }

    @Test
    public void test_service_method() {
        TestContext.get().mockery().checking(new Expectations() {
            {
                one(repository).findAll();
                will(returnValue(Collections.EMPTY_LIST));
            }
        });
        service.doSomething();
        assertBlaBlaBla ...
    }

    @AfterMethod
    public void verify() {
        TestContext.get().mockery().assertIsSatisfied();
    }
}
}}}