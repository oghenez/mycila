#summary Google Guice Plugin
#sidebar PluginBar

*Google Guice [http://code.google.com/p/google-guice/ official website]*

Guice integration enables you to automatically create the injector with the module and even with the bindings you provide.

*Annotations*

 * [http://mycila.googlecode.com/svn/mycila-testing/trunk/mycila-testing-plugins/mycila-testing-guice/src/main/java/com/mycila/testing/plugin/guice/GuiceContext.java @GuiceContext]: Used on a test class to specify a list of Guice modules
 * [http://mycila.googlecode.com/svn/mycila-testing/trunk/mycila-testing-plugins/mycila-testing-guice/src/main/java/com/mycila/testing/plugin/guice/ModuleProvider.java @ModuleProvider]: Used on some methods that provides Guice modules
 * [http://mycila.googlecode.com/svn/mycila-testing/trunk/mycila-testing-plugins/mycila-testing-guice/src/main/java/com/mycila/testing/plugin/guice/Bind.java @Bind]: Used on fields or methods to add specific bindings.

*Example 1: loading Guice modules and injecting dependencies*

{{{
@GuiceContext(AModule.class)
public final class GuiceContextTest {

    @Inject
    @Named("service1")
    Service service1;

    @Inject
    Provider<Service2> service2;

    @Inject
    Injector injector;

    @Test
    public void setup() {
        TestSetup.setup(this);
    }

    @Test
    public void test_something() {
        //...
    }
}
}}}

*Example 2: providing some additional modules*

Provider methods are really useful when your module do not have a default constructor to be automatically instantiated.

Methods returning modules must have one of the following return types: Module, Module[] or Iterable<Module> or any subtypes of these.

{{{
public final class ModuleProviderTest {

    @Inject
    Injector injector;

    @Test
    public void setup() {
        TestSetup.setup(this);
    }

    @ModuleProvider
    private Module providesOneModule() {
        return new MyModule1WithParams("hello", 6);
    }

    @ModuleProvider
    Module[] providesAnArrayOfModules() {
        return new Module[]{new MyModule2WithParams("hello", 6), new MyModule3WithParams("hello", 6)};
    }

    @ModuleProvider
    public Iterable<Module> provides3() {
        return new ArrayList<Module>() {{
            add(new MyModule4WithParams("hello", 6));
            add(new MyModule5WithParams("hello", 6));
        }};
    }

}
}}}

*Example 3: providing some additional bindings*

You can add specific bindings directly by annotating fields or method. A provider is used to access there value or execute them.

The @Bind annotation supports two optional parameters:

 * An annotation used to precise the binding (used for bind(...).annotatedBy(...))
 * A scope if you want for example to precise the scope

Here is an example using @Bind on fields. As you can see, you can use a trick: since bindings by default are not singletons, you can change the value of the field, and it will change the binding. But if you put the Singleton scope, the first value is always returned.

{{{
public final class BindFieldTest {

    @Bind
    String a = "helloa";

    @Bind(annotatedBy = Named.class, scope = Singleton.class)
    String b = "hellob";

    @Inject
    Injector injector;

    @Test
    public void test_bind() {
        TestSetup.setup(this);
        assertEquals(injector.getInstance(String.class), "helloa");
        assertEquals(injector.getInstance(Key.get(String.class, Named.class)), "hellob");
        b = "changedb";
        a = "changeda";
        assertEquals(injector.getInstance(String.class), "changeda");
        assertEquals(injector.getInstance(Key.get(String.class, Named.class)), "hellob");
    }
}
}}}

Here is now an example using method. Like before, the returned values of the methods that are binded can change.

{{{
public final class BindMethodTest {

    String a = "helloa";
    String b = "hellob";

    @Inject
    Injector injector;

    @Bind
    String a() {
        return a;
    }

    @Bind(annotatedBy = Named.class, scope = Singleton.class)
    String b() {
        return b;
    }

    @Test
    public void test_bind() {
        TestSetup.setup(this);
        assertEquals(injector.getInstance(String.class), "helloa");
        assertEquals(injector.getInstance(Key.get(String.class, Named.class)), "hellob");
        b = "changedb";
        a = "changeda";
        assertEquals(injector.getInstance(String.class), "changeda");
        assertEquals(injector.getInstance(Key.get(String.class, Named.class)), "hellob");
    }
}
}}}